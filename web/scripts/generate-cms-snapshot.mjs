#!/usr/bin/env node

import fs from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const SCRIPT_DIR = path.dirname(fileURLToPath(import.meta.url));
const WEB_ROOT = path.resolve(SCRIPT_DIR, "..");
const DEFAULT_OUT_PATH = path.resolve(WEB_ROOT, "lib/content.generated.ts");
const SUPPORTED_LOCALES = new Set(["nl", "en", "no"]);

function usage() {
  return [
    "Usage: npm run cms:snapshot -- [options]",
    "",
    "Options:",
    "  --site-id <uuid>        CMS site id (default: NEXT_PUBLIC_CMS_SITE_ID)",
    "  --supabase-url <url>    Supabase project URL (default: NEXT_PUBLIC_SUPABASE_URL)",
    "  --api-key <key>         Supabase API key (default: SUPABASE_SERVICE_ROLE_KEY, fallback NEXT_PUBLIC_SUPABASE_ANON_KEY)",
    "  --out <path>            Output file (default: web/lib/content.generated.ts)",
    "  --help                  Show this help",
    "",
    "Example:",
    "  npm run cms:snapshot -- --site-id <site-id> --supabase-url https://xxx.supabase.co --api-key <service-role-key>",
  ].join("\n");
}

function parseArgs(argv) {
  const args = {};

  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i];
    if (token === "--help" || token === "-h") {
      args.help = true;
      continue;
    }

    if (!token.startsWith("--")) {
      throw new Error(`Unexpected argument: ${token}`);
    }

    const key = token.slice(2);
    const next = argv[i + 1];
    if (!next || next.startsWith("--")) {
      throw new Error(`Missing value for argument: ${token}`);
    }
    args[key] = next;
    i += 1;
  }

  return args;
}

function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}

function resolveOutPath(input) {
  if (!input) return DEFAULT_OUT_PATH;
  return path.isAbsolute(input) ? input : path.resolve(WEB_ROOT, input);
}

function createEmptySnapshot() {
  return {
    siteConfig: {},
    cabin: {},
    home: {},
    practical: {},
    area: {},
    privacy: {},
    contactForm: {},
  };
}

function mapDocument(snapshot, row) {
  const locale = row.locale;
  if (!SUPPORTED_LOCALES.has(locale)) return false;
  if (!isRecord(row.content)) return false;

  const content = row.content;
  const contentType = row.content_type;
  const slug = row.slug;

  if (contentType === "site_config" && slug === "main") {
    snapshot.siteConfig[locale] = content;
    return true;
  }
  if (contentType === "cabin" && slug === "main") {
    snapshot.cabin[locale] = content;
    return true;
  }
  if (contentType === "page" && slug === "home") {
    snapshot.home[locale] = content;
    return true;
  }
  if (contentType === "page" && slug === "practical") {
    snapshot.practical[locale] = content;
    return true;
  }
  if (contentType === "page" && slug === "area") {
    snapshot.area[locale] = content;
    return true;
  }
  if (contentType === "page" && slug === "privacy") {
    snapshot.privacy[locale] = content;
    return true;
  }
  if (contentType === "contact_form" && slug === "main") {
    snapshot.contactForm[locale] = content;
    return true;
  }
  return false;
}

function renderSnapshotFile(snapshot, metadata) {
  const serializedSnapshot = JSON.stringify(snapshot, null, 2);

  return `/**
 * AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
 *
 * Generated by: scripts/generate-cms-snapshot.mjs
 * Generated at: ${metadata.generatedAt}
 * Site ID: ${metadata.siteId}
 * Matched docs: ${metadata.matchedDocs}
 */

import type { Locale } from "./i18n";
import type {
  CabinContent,
  ContactFormSectionContent,
  LocalizedContent,
  PracticalContent,
  SiteConfig,
} from "./content";

type LocalizedMap<T> = Partial<Record<Locale, T>>;

export type GeneratedContentSnapshot = {
  siteConfig: LocalizedMap<Partial<SiteConfig>>;
  cabin: LocalizedMap<CabinContent>;
  home: LocalizedMap<Partial<LocalizedContent>>;
  practical: LocalizedMap<PracticalContent>;
  area: LocalizedMap<LocalizedContent["area"]>;
  privacy: LocalizedMap<LocalizedContent["privacy"]>;
  contactForm: LocalizedMap<ContactFormSectionContent>;
};

export const generatedContentSnapshot: GeneratedContentSnapshot = ${serializedSnapshot};
`;
}

async function fetchPublishedDocuments({ supabaseUrl, apiKey, siteId }) {
  const url = new URL("/rest/v1/cms_documents", supabaseUrl);
  url.searchParams.set("select", "content_type,slug,locale,content");
  url.searchParams.set("site_id", `eq.${siteId}`);
  url.searchParams.set("status", "eq.published");
  url.searchParams.set("order", "content_type.asc,slug.asc,locale.asc");
  url.searchParams.set("limit", "1000");

  const response = await fetch(url, {
    method: "GET",
    headers: {
      apikey: apiKey,
      Authorization: `Bearer ${apiKey}`,
      Accept: "application/json",
    },
  });

  if (!response.ok) {
    const body = await response.text().catch(() => "");
    throw new Error(`Supabase query failed (${response.status}): ${body}`);
  }

  const payload = await response.json();
  if (!Array.isArray(payload)) {
    throw new Error("Supabase response is not an array.");
  }
  return payload;
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  if (args.help) {
    process.stdout.write(`${usage()}\n`);
    return;
  }

  const siteId = args["site-id"] ?? process.env.NEXT_PUBLIC_CMS_SITE_ID ?? "";
  const supabaseUrl = args["supabase-url"] ?? process.env.NEXT_PUBLIC_SUPABASE_URL ?? "";
  const apiKey =
    args["api-key"] ??
    process.env.SUPABASE_SERVICE_ROLE_KEY ??
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ??
    "";
  const outPath = resolveOutPath(args.out);

  if (!siteId) {
    throw new Error("Missing site id. Set --site-id or NEXT_PUBLIC_CMS_SITE_ID.");
  }
  if (!supabaseUrl) {
    throw new Error(
      "Missing Supabase URL. Set --supabase-url or NEXT_PUBLIC_SUPABASE_URL.",
    );
  }
  if (!apiKey) {
    throw new Error(
      "Missing API key. Set --api-key or SUPABASE_SERVICE_ROLE_KEY (preferred).",
    );
  }

  const normalizedUrl = supabaseUrl.replace(/\/+$/, "");
  const rows = await fetchPublishedDocuments({
    supabaseUrl: normalizedUrl,
    apiKey,
    siteId,
  });

  const snapshot = createEmptySnapshot();
  let matchedDocs = 0;

  for (const row of rows) {
    if (!isRecord(row)) continue;
    if (mapDocument(snapshot, row)) matchedDocs += 1;
  }

  const fileContent = renderSnapshotFile(snapshot, {
    generatedAt: new Date().toISOString(),
    siteId,
    matchedDocs,
  });

  await fs.writeFile(outPath, fileContent, "utf8");
  process.stdout.write(
    `Generated CMS snapshot: ${path.relative(WEB_ROOT, outPath)} (${matchedDocs} mapped docs)\n`,
  );
}

main().catch((error) => {
  process.stderr.write(`${error instanceof Error ? error.message : String(error)}\n`);
  process.stderr.write(`${usage()}\n`);
  process.exitCode = 1;
});
